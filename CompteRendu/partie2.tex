
\section{Connaissances pour la suite}
\label{sec:preliminaires}

\par Avant de commencer concrètement le projet, une certaine organisation s'impose, ainsi qu'une énumération de certaines connaissances nécessaires pour la suite. 

\subsection{Gestion de version avec Git}
\label{sec:gestion-de-version}

\input{partie21}

\subsection{OAR : résumé des commandes utilisées}
\label{sec:oar-:-resume}

\input{partie22}


\subsection{Fonctionnement de JSch}

\par \emph{JSch} est un package Java permettant d'effectuer des connexions SSH. Il permet de faire à peu près tout ce qu'on lui demande, mais manque de documentation. Les résultats s'obtiennent à partir de tests et de comparaison de morceaux de code déjà existants. Après un certain temps de pratique, son utilisation devient cependant assez compréhensible.

\par Le problème principal de la connexion SSH est d'établir d'une part la connexion avec authentification, et d'autre part de la maintenir active tout en communiquant avec la machine distante, via un canal actif, c'est là tout l'objet de JSch.

\subsubsection{Etablissement d'une connexion}
\label{sec:etabl-dune-conn}

\par Commençons donc par établir une connexion à l'aide d'une session (et donc d'un objet Session) :

\begin{minted}[frame=single,linenos,mathescape]{java}
  java.util.Properties config = new java.util.Properties(); 
  config.put("StrictHostKeyChecking", "no");
  
  JSch jsch = new JSch();

  // Configure la session avec les informations de base
  // Le username, le host, et le port, puis le password
  Session session = jsch.getSession("user", "host", 22);
  session.setPassword("password");
  session.setConfig(config);

  // Specifie la duree de la session
  session.setServerAliveInterval(3600000);
  session.connect();

  // Message de confirmation envoye sur la sortie standard
  System.out.println( "Connecté à " + session.getHost() + 
      " sous le port " + session.getPort() );
\end{minted}

\par Ce morceau de code, utilisé dans le programme, permet d'obtenir la session correspondant à une connexion active. De cette session, on peut obtenir un canal de transmission entre le shell et l'interface java, ce qui permet de communiquer.

\subsubsection{Utilisation d'un canal pour communiquer avec le shell distant}
\label{sec:util-dun-canal}

\par En supposant acquise notre session, connectée à la machine distante dont le shell nous intéresse, étudions le morceau de code suivant :

\begin{minted}[frame=single,linenos,mathescape]{java}
  channel = session.openChannel("shell");
  
  in = channel.getInputStream();
  out = channel.getOutputStream();
  
  ((ChannelShell) channel).setPtyType("vt102");
  channel.connect();
\end{minted}

\par Il existe plusieurs types d'objets \texttt{Channel}, les deux plus courants étant : \texttt{ChannelShell} et \texttt{ChannelExec}. Le premier type est destiné à une utilisation intéractive alors que le second prévoit plutôt une communication par batch. Notre but étant de pouvoir manipuler des noeuds de manière intéractive, nous nous intéresserons donc au premier type : \texttt{ChannelShell}. Un \texttt{Channel} est un canal, permettant donc la communication dans les deux sens, en supposant une session active (qui identifie l'utilisateur connecté au serveur). Sans cette session, permettant de garder active l'authentification, aucun canal ne peut exister.
\par Le canal est principalement constitué de deux composantes, un \texttt{InputBuffer}, et un \texttt{OutputBuffer}. Il s'agit de deux boîtes aux lettres, une de réception (input) et une d'envoi (output) permettant d'envoyer et recevoir les données de la part du serveur (du shell distant). 

\subsubsection{Envoi d'une commande au shell distant}
\label{sec:envoi-dune-commande}

\par Voyons donc comment communiquer avec ce shell distant, à l'aide des buffers \texttt{in} et \texttt{out}. La fonction \texttt{sendCommand} permet d'envoyer une commande (à partir de sa chaîne de caractères) :

\begin{minted}[frame=single,linenos,mathescape]{java}
public void sendCommand(String command){
  try {
    
    out.write(command.getBytes());
    out.write("\n".getBytes());
    out.flush();
    
  }
  catch (Exception e) {
    System.out.println("Error " + e.getMessage());
    e.printStackTrace();
  }
  
  this.readReceivedMessage();
}
\end{minted}

\par Une particularité des buffers est qu'ils ne traitent qu'avec des bytes. Notre commande étant une chaîne de caractères, on la transforme en bytes avant de la mettre dans le buffer d'envoi \texttt{out}.
\par La méthode \texttt{readReceivedMessage()} permet de récupérer le contenu du buffer \texttt{in} sous forme de chaîne pour pouvoir l'afficher.

\begin{minted}[frame=single,linenos,mathescape]{java}
  public String readReceivedMessage (){
    
    String msg="";
    
    try {
      
      byte[] tmp=new byte[1024];
      String tmp_str="";
      
      while(in.available() > 0){
        int i= in.read(tmp, 0, 1024);
        tmp_str = new String(tmp, 0, i);
        msg+=tmp_str;
        if(channel.isClosed()){
          System.out.println("exit-status: "+channel.getExitStatus());
          break;
        }
      }
      System.out.print(msg);
      
    }
    catch (Exception e) {
      System.out.println("Error " + e.getMessage());
      e.printStackTrace();
    }
    return msg;
  }
\end{minted}

\par Globalement, la méthode \texttt{available} permet de tester s'il y a du contenu à récupérer dans le buffer, et tant que c'est le cas, on récupère ce contenu par paquets de 1024 bytes (octets) que l'on transforme en chaîne, puis que l'on concatène dans un accumulateur qu'on renvoie en toute fin de fonction.

\par Le problème majeur de cette fonction est qu'elle peut vérifier un peu trop tôt le contenu du buffer de réception, et par conséquent "rater" l'affichage du message...

\par En effet, ce système de buffer étant asynchrone, il faut un moyen répétitif pour vérifier leur contenu. Si le serveur met beaucoup de temps à répondre, le buffer mettra par conséquent beaucoup de temps à se remplir. Mais cette problématique ne concerne déjà plus JSch...


%\subsection{Vocabulaire du High Performance Computing (HPC)}
%\label{sec:vocab-spec-du}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "CompteRendu"
%%% End: 
